/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include <stdint.h>
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"
#pragma GCC diagnostic pop

#include "src/lib/raceup_board/raceup_board.h"
#include <stddef.h>

IFX_ALIGN(4) IfxCpu_syncEvent g_cpuSyncEvent = 0;

void read_mailbox(struct CanMailbox* recv_mailbox, char* mailbox_name)
{
  CanMessage mex = {0};
  if (hardware_mailbox_read(recv_mailbox, &mex))
  {
    serial_write_raw("mex received ");
    serial_write_raw(mailbox_name);
    serial_write_raw(" :");

    serial_write_raw("id: ");
    serial_write_uint32_t(mex.id);

    serial_write_raw(", size: ");
    serial_write_uint8_t(mex.message_size);

    serial_write_raw(", data word 1: ");
    serial_write_uint32_t(((uint32_t*) &mex.full_word)[0]);
    serial_write_raw(", data word 2: ");
    serial_write_uint32_t(((uint32_t*) &mex.full_word)[1]);

    serial_write_str("");
  }
}

void core0_main(void)
{
  int8_t err =0;
  CanMessage mex = {0};
  struct CanNode* node = NULL;
  struct CanMailbox* recv_mailbox = NULL;
  struct CanMailbox* recv_mailbox_1 = NULL;
  struct CanMailbox* recv_mailbox_2 = NULL;
  struct CanMailbox* send_mailbox= NULL;

  IfxCpu_enableInterrupts();

  /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
   * Enable the watchdogs and service them periodically if it is required
   */
  IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
  IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());

  /* Wait for CPU sync event */
  IfxCpu_emitEvent(&g_cpuSyncEvent);
  IfxCpu_waitEvent(&g_cpuSyncEvent, 1);

  serial_setup(115200);

  
  while((err = hardware_init_can(CAN_DEBUG, _500_KBYTE_S_)) != 0)
  {
    serial_write_str("init can debug node failed with err: ");
    switch (err)
    {
      case -1:
        serial_write_str("invalid node module");
        break;
      case -2:
        serial_write_str("can init node failed");
        break;
      default:
        serial_write_str("unrecognized error");
        break;
    
    }
  }

  node = hardware_init_can_get_ref_node(CAN_DEBUG);
  while(!node)
  {
    node = hardware_init_can_get_ref_node(CAN_DEBUG);
    serial_write_str("get ref can debug node failed");
  }

  recv_mailbox = hardware_get_mailbox_single_mex(node, RECV_MAILBOX, 0x2, 1);
  while(!recv_mailbox)
  {
   recv_mailbox = hardware_get_mailbox_single_mex(node, RECV_MAILBOX, 0x2, 1);
    serial_write_str("failed init recv mailbox");
  }

  recv_mailbox_1 = hardware_get_mailbox_single_mex(node, RECV_MAILBOX, 0x3, 1);
  while(!recv_mailbox_1)
  {
   recv_mailbox_1 = hardware_get_mailbox_single_mex(node, RECV_MAILBOX, 0x3, 1);
    serial_write_str("failed init recv mailbox_1");
  }

  recv_mailbox_2 = hardware_get_mailbox_single_mex(node, RECV_MAILBOX, 0x4, 1);
  while(!recv_mailbox_2)
  {
   recv_mailbox_2 = hardware_get_mailbox_single_mex(node, RECV_MAILBOX, 0x4, 1);
    serial_write_str("failed init recv mailbox_2");
  }

  send_mailbox = hardware_get_mailbox_single_mex(node, SEND_MAILBOX, 0x10, 8);
  while(!send_mailbox)
  {
   send_mailbox = hardware_get_mailbox_single_mex(node, SEND_MAILBOX, 0x10, 8);
    serial_write_str("failed init send mailbox");
  }

  serial_write_str("init done test started");

  mex.id = 12;
  mex.message_size = 2;
  mex.full_word = 128;

  serial_write_str("test sending mex raw");
  hardware_write_can(node, &mex);

  time_var_microseconds t =0;
  uint8_t counter = 0;

  while(1)
  {
    read_mailbox(recv_mailbox, "mailbox_0");
    read_mailbox(recv_mailbox_1, "mailbox_1");
    read_mailbox(recv_mailbox_2, "mailbox_2");

    ACTION_ON_FREQUENCY(t, get_tick_from_millis(5000))
    {
      serial_write_raw("alive loop: ");
      counter = (counter +1)%10;
      serial_write_uint8_t(counter);
      serial_write_str("");
      int8_t err=0;
      if((err=hardware_mailbox_send(send_mailbox, 32))<0)
      {
        serial_write_raw("send mailbox failed with err: ");
        serial_write_int8_t(err);
        serial_write_str("");
      }
    }
  }
}
